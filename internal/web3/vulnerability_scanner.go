package web3

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/ai-agentic-browser/pkg/observability"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/google/uuid"
)

// VulnerabilityScanner provides smart contract vulnerability scanning
type VulnerabilityScanner struct {
	clients map[int]*ethclient.Client
	logger  *observability.Logger
	rules   map[string]*VulnerabilityRule
}

// VulnerabilityRule represents a vulnerability detection rule
type VulnerabilityRule struct {
	ID          string                 `json:"id"`
	Name        string                 `json:"name"`
	Description string                 `json:"description"`
	Severity    VulnerabilitySeverity  `json:"severity"`
	Category    VulnerabilityCategory  `json:"category"`
	Patterns    []string               `json:"patterns"`
	Conditions  []string               `json:"conditions"`
	Remediation string                 `json:"remediation"`
	References  []string               `json:"references"`
	Metadata    map[string]interface{} `json:"metadata"`
}

// VulnerabilitySeverity represents the severity of a vulnerability
type VulnerabilitySeverity string

const (
	SeverityCritical VulnerabilitySeverity = "critical"
	SeverityHigh     VulnerabilitySeverity = "high"
	SeverityMedium   VulnerabilitySeverity = "medium"
	SeverityLow      VulnerabilitySeverity = "low"
	SeverityInfo     VulnerabilitySeverity = "info"
)

// VulnerabilityCategory represents the category of a vulnerability
type VulnerabilityCategory string

const (
	CategoryReentrancy      VulnerabilityCategory = "reentrancy"
	CategoryOverflow        VulnerabilityCategory = "integer_overflow"
	CategoryAccessControl   VulnerabilityCategory = "access_control"
	CategoryLogicError      VulnerabilityCategory = "logic_error"
	CategoryDenialOfService VulnerabilityCategory = "denial_of_service"
	CategoryFrontRunning    VulnerabilityCategory = "front_running"
	CategoryTimestamp       VulnerabilityCategory = "timestamp_dependence"
	CategoryRandomness      VulnerabilityCategory = "weak_randomness"
)

// VulnerabilityReport represents a vulnerability scan report
type VulnerabilityReport struct {
	ID              uuid.UUID              `json:"id"`
	ContractAddress string                 `json:"contract_address"`
	ChainID         int                    `json:"chain_id"`
	ScanType        string                 `json:"scan_type"`
	Vulnerabilities []Vulnerability        `json:"vulnerabilities"`
	Summary         VulnerabilitySummary   `json:"summary"`
	Recommendations []string               `json:"recommendations"`
	ScannedAt       time.Time              `json:"scanned_at"`
	ScanDuration    time.Duration          `json:"scan_duration"`
	Metadata        map[string]interface{} `json:"metadata"`
}

// Vulnerability represents a detected vulnerability
type Vulnerability struct {
	ID          string                 `json:"id"`
	RuleID      string                 `json:"rule_id"`
	Name        string                 `json:"name"`
	Description string                 `json:"description"`
	Severity    VulnerabilitySeverity  `json:"severity"`
	Category    VulnerabilityCategory  `json:"category"`
	Location    string                 `json:"location"`
	Evidence    []string               `json:"evidence"`
	Impact      string                 `json:"impact"`
	Remediation string                 `json:"remediation"`
	Confidence  float64                `json:"confidence"`
	References  []string               `json:"references"`
	Metadata    map[string]interface{} `json:"metadata"`
}

// VulnerabilitySummary provides a summary of the scan results
type VulnerabilitySummary struct {
	TotalVulnerabilities int                           `json:"total_vulnerabilities"`
	BySeverity           map[VulnerabilitySeverity]int `json:"by_severity"`
	ByCategory           map[VulnerabilityCategory]int `json:"by_category"`
	RiskScore            int                           `json:"risk_score"`
	SecurityGrade        SafetyGrade                   `json:"security_grade"`
}

// ScanRequest represents a vulnerability scan request
type ScanRequest struct {
	ContractAddress string                 `json:"contract_address"`
	ChainID         int                    `json:"chain_id"`
	ScanType        string                 `json:"scan_type"`
	Rules           []string               `json:"rules"`
	Options         map[string]interface{} `json:"options"`
}

// NewVulnerabilityScanner creates a new vulnerability scanner
func NewVulnerabilityScanner(clients map[int]*ethclient.Client, logger *observability.Logger) *VulnerabilityScanner {
	scanner := &VulnerabilityScanner{
		clients: clients,
		logger:  logger,
		rules:   make(map[string]*VulnerabilityRule),
	}

	// Initialize vulnerability rules
	scanner.initializeRules()

	return scanner
}

// ScanContract performs a comprehensive vulnerability scan of a smart contract
func (v *VulnerabilityScanner) ScanContract(ctx context.Context, req ScanRequest) (*VulnerabilityReport, error) {
	ctx, span := observability.SpanFromContext(ctx).TracerProvider().Tracer("vulnerability-scanner").Start(ctx, "scanner.ScanContract")
	defer span.End()

	startTime := time.Now()

	// Create scan report
	report := &VulnerabilityReport{
		ID:              uuid.New(),
		ContractAddress: req.ContractAddress,
		ChainID:         req.ChainID,
		ScanType:        req.ScanType,
		Vulnerabilities: []Vulnerability{},
		ScannedAt:       startTime,
		Metadata:        req.Options,
	}

	// Get client for the chain
	client, exists := v.clients[req.ChainID]
	if !exists {
		return nil, fmt.Errorf("no client available for chain ID: %d", req.ChainID)
	}

	// Get contract bytecode
	contractAddr := common.HexToAddress(req.ContractAddress)
	bytecode, err := client.CodeAt(ctx, contractAddr, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to get contract bytecode: %w", err)
	}

	if len(bytecode) == 0 {
		return nil, fmt.Errorf("no contract code found at address: %s", req.ContractAddress)
	}

	// Perform static analysis
	if err := v.performStaticAnalysis(ctx, bytecode, report); err != nil {
		v.logger.Warn(ctx, "Static analysis failed", map[string]interface{}{
			"error": err.Error(),
		})
	}

	// Perform dynamic analysis if requested
	if req.ScanType == "comprehensive" || req.ScanType == "dynamic" {
		if err := v.performDynamicAnalysis(ctx, client, contractAddr, report); err != nil {
			v.logger.Warn(ctx, "Dynamic analysis failed", map[string]interface{}{
				"error": err.Error(),
			})
		}
	}

	// Generate summary
	v.generateSummary(report)

	// Calculate scan duration
	report.ScanDuration = time.Since(startTime)

	v.logger.Info(ctx, "Vulnerability scan completed", map[string]interface{}{
		"contract_address":      req.ContractAddress,
		"vulnerabilities_found": len(report.Vulnerabilities),
		"scan_duration":         report.ScanDuration.String(),
		"risk_score":            report.Summary.RiskScore,
	})

	return report, nil
}

// performStaticAnalysis performs static analysis of contract bytecode
func (v *VulnerabilityScanner) performStaticAnalysis(ctx context.Context, bytecode []byte, report *VulnerabilityReport) error {
	bytecodeHex := common.Bytes2Hex(bytecode)

	// Apply all vulnerability rules
	for ruleID, rule := range v.rules {
		vulnerabilities := v.applyRule(rule, bytecodeHex, "static")
		for _, vuln := range vulnerabilities {
			vuln.RuleID = ruleID
			report.Vulnerabilities = append(report.Vulnerabilities, vuln)
		}
	}

	return nil
}

// performDynamicAnalysis performs dynamic analysis of contract behavior
func (v *VulnerabilityScanner) performDynamicAnalysis(ctx context.Context, client *ethclient.Client, contractAddr common.Address, report *VulnerabilityReport) error {
	// This would perform dynamic analysis by simulating transactions
	// For now, add placeholder dynamic checks

	// Check for gas limit issues
	v.checkGasLimitIssues(ctx, client, contractAddr, report)

	// Check for state manipulation vulnerabilities
	v.checkStateManipulation(ctx, client, contractAddr, report)

	return nil
}

// applyRule applies a vulnerability detection rule to bytecode
func (v *VulnerabilityScanner) applyRule(rule *VulnerabilityRule, bytecode string, analysisType string) []Vulnerability {
	var vulnerabilities []Vulnerability

	// Check if any patterns match
	for _, pattern := range rule.Patterns {
		if strings.Contains(bytecode, pattern) {
			vuln := Vulnerability{
				ID:          uuid.New().String(),
				Name:        rule.Name,
				Description: rule.Description,
				Severity:    rule.Severity,
				Category:    rule.Category,
				Location:    fmt.Sprintf("Bytecode offset: %d", strings.Index(bytecode, pattern)),
				Evidence:    []string{fmt.Sprintf("Pattern found: %s", pattern)},
				Impact:      v.calculateImpact(rule.Severity),
				Remediation: rule.Remediation,
				Confidence:  0.8, // Default confidence
				References:  rule.References,
				Metadata:    map[string]interface{}{"analysis_type": analysisType},
			}
			vulnerabilities = append(vulnerabilities, vuln)
		}
	}

	return vulnerabilities
}

// calculateImpact calculates the impact description based on severity
func (v *VulnerabilityScanner) calculateImpact(severity VulnerabilitySeverity) string {
	switch severity {
	case SeverityCritical:
		return "Critical security risk - immediate action required"
	case SeverityHigh:
		return "High security risk - should be addressed promptly"
	case SeverityMedium:
		return "Medium security risk - should be reviewed"
	case SeverityLow:
		return "Low security risk - minor concern"
	case SeverityInfo:
		return "Informational - no immediate security risk"
	default:
		return "Unknown impact"
	}
}

// checkGasLimitIssues checks for gas limit related vulnerabilities
func (v *VulnerabilityScanner) checkGasLimitIssues(ctx context.Context, client *ethclient.Client, contractAddr common.Address, report *VulnerabilityReport) {
	// This would simulate transactions to check for gas limit issues
	// For now, add a placeholder check

	vuln := Vulnerability{
		ID:          uuid.New().String(),
		Name:        "Gas Limit Analysis",
		Description: "Analysis of gas consumption patterns",
		Severity:    SeverityInfo,
		Category:    CategoryDenialOfService,
		Location:    "Dynamic analysis",
		Evidence:    []string{"Gas consumption analysis performed"},
		Impact:      "Informational - gas usage patterns analyzed",
		Confidence:  0.5,
		Metadata:    map[string]interface{}{"analysis_type": "dynamic"},
	}

	report.Vulnerabilities = append(report.Vulnerabilities, vuln)
}

// checkStateManipulation checks for state manipulation vulnerabilities
func (v *VulnerabilityScanner) checkStateManipulation(ctx context.Context, client *ethclient.Client, contractAddr common.Address, report *VulnerabilityReport) {
	// This would check for state manipulation vulnerabilities
	// For now, add a placeholder check

	vuln := Vulnerability{
		ID:          uuid.New().String(),
		Name:        "State Manipulation Analysis",
		Description: "Analysis of state manipulation possibilities",
		Severity:    SeverityInfo,
		Category:    CategoryLogicError,
		Location:    "Dynamic analysis",
		Evidence:    []string{"State manipulation analysis performed"},
		Impact:      "Informational - state manipulation patterns analyzed",
		Confidence:  0.5,
		Metadata:    map[string]interface{}{"analysis_type": "dynamic"},
	}

	report.Vulnerabilities = append(report.Vulnerabilities, vuln)
}

// generateSummary generates a summary of the scan results
func (v *VulnerabilityScanner) generateSummary(report *VulnerabilityReport) {
	summary := VulnerabilitySummary{
		TotalVulnerabilities: len(report.Vulnerabilities),
		BySeverity:           make(map[VulnerabilitySeverity]int),
		ByCategory:           make(map[VulnerabilityCategory]int),
	}

	// Count vulnerabilities by severity and category
	for _, vuln := range report.Vulnerabilities {
		summary.BySeverity[vuln.Severity]++
		summary.ByCategory[vuln.Category]++
	}

	// Calculate risk score (0-100)
	riskScore := 0
	riskScore += summary.BySeverity[SeverityCritical] * 25
	riskScore += summary.BySeverity[SeverityHigh] * 15
	riskScore += summary.BySeverity[SeverityMedium] * 8
	riskScore += summary.BySeverity[SeverityLow] * 3
	riskScore += summary.BySeverity[SeverityInfo] * 1

	if riskScore > 100 {
		riskScore = 100
	}
	summary.RiskScore = riskScore

	// Assign security grade
	switch {
	case riskScore >= 80:
		summary.SecurityGrade = SafetyGradeF
	case riskScore >= 60:
		summary.SecurityGrade = SafetyGradeD
	case riskScore >= 40:
		summary.SecurityGrade = SafetyGradeC
	case riskScore >= 20:
		summary.SecurityGrade = SafetyGradeB
	default:
		summary.SecurityGrade = SafetyGradeA
	}

	report.Summary = summary

	// Generate recommendations
	v.generateRecommendations(report)
}

// generateRecommendations generates security recommendations based on findings
func (v *VulnerabilityScanner) generateRecommendations(report *VulnerabilityReport) {
	recommendations := []string{}

	if report.Summary.BySeverity[SeverityCritical] > 0 {
		recommendations = append(recommendations, "CRITICAL: Do not interact with this contract until critical vulnerabilities are fixed")
	}

	if report.Summary.BySeverity[SeverityHigh] > 0 {
		recommendations = append(recommendations, "HIGH RISK: Exercise extreme caution when interacting with this contract")
	}

	if report.Summary.BySeverity[SeverityMedium] > 0 {
		recommendations = append(recommendations, "MEDIUM RISK: Review identified issues before proceeding")
	}

	if report.Summary.ByCategory[CategoryReentrancy] > 0 {
		recommendations = append(recommendations, "Reentrancy vulnerabilities detected - verify state changes are protected")
	}

	if report.Summary.ByCategory[CategoryAccessControl] > 0 {
		recommendations = append(recommendations, "Access control issues detected - verify permissions are properly implemented")
	}

	if len(recommendations) == 0 {
		recommendations = append(recommendations, "No major security issues detected, but always exercise caution")
	}

	report.Recommendations = recommendations
}

// initializeRules initializes the vulnerability detection rules
func (v *VulnerabilityScanner) initializeRules() {
	// Reentrancy vulnerability rule
	v.rules["reentrancy"] = &VulnerabilityRule{
		ID:          "reentrancy",
		Name:        "Reentrancy Vulnerability",
		Description: "Contract may be vulnerable to reentrancy attacks",
		Severity:    SeverityCritical,
		Category:    CategoryReentrancy,
		Patterns:    []string{"f1", "55"}, // CALL and SSTORE opcodes
		Remediation: "Use reentrancy guards or checks-effects-interactions pattern",
		References:  []string{"https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/"},
	}

	// Integer overflow rule
	v.rules["integer_overflow"] = &VulnerabilityRule{
		ID:          "integer_overflow",
		Name:        "Integer Overflow/Underflow",
		Description: "Contract may be vulnerable to integer overflow/underflow",
		Severity:    SeverityHigh,
		Category:    CategoryOverflow,
		Patterns:    []string{"01", "03"}, // ADD and SUB opcodes without checks
		Remediation: "Use SafeMath library or Solidity 0.8.0+ with built-in overflow checks",
		References:  []string{"https://consensys.github.io/smart-contract-best-practices/attacks/insecure-arithmetic/"},
	}

	// Unchecked external call rule
	v.rules["unchecked_call"] = &VulnerabilityRule{
		ID:          "unchecked_call",
		Name:        "Unchecked External Call",
		Description: "External call return value not checked",
		Severity:    SeverityMedium,
		Category:    CategoryLogicError,
		Patterns:    []string{"f1"}, // CALL opcode
		Remediation: "Always check return values of external calls",
		References:  []string{"https://consensys.github.io/smart-contract-best-practices/recommendations/#handle-errors-in-external-calls"},
	}

	// Selfdestruct rule
	v.rules["selfdestruct"] = &VulnerabilityRule{
		ID:          "selfdestruct",
		Name:        "Selfdestruct Function",
		Description: "Contract contains selfdestruct functionality",
		Severity:    SeverityHigh,
		Category:    CategoryAccessControl,
		Patterns:    []string{"ff"}, // SELFDESTRUCT opcode
		Remediation: "Ensure selfdestruct is properly protected and necessary",
		References:  []string{"https://consensys.github.io/smart-contract-best-practices/recommendations/#be-aware-of-the-tradeoffs-between-send-transfer-and-callvalue"},
	}

	// Delegatecall rule
	v.rules["delegatecall"] = &VulnerabilityRule{
		ID:          "delegatecall",
		Name:        "Delegatecall Usage",
		Description: "Contract uses delegatecall which can be dangerous",
		Severity:    SeverityMedium,
		Category:    CategoryAccessControl,
		Patterns:    []string{"f4"}, // DELEGATECALL opcode
		Remediation: "Ensure delegatecall targets are trusted and validated",
		References:  []string{"https://consensys.github.io/smart-contract-best-practices/recommendations/#be-aware-of-the-tradeoffs-between-send-transfer-and-callvalue"},
	}

	// Timestamp dependence rule
	v.rules["timestamp_dependence"] = &VulnerabilityRule{
		ID:          "timestamp_dependence",
		Name:        "Timestamp Dependence",
		Description: "Contract logic depends on block timestamp",
		Severity:    SeverityLow,
		Category:    CategoryTimestamp,
		Patterns:    []string{"42"}, // TIMESTAMP opcode
		Remediation: "Avoid using block.timestamp for critical logic",
		References:  []string{"https://consensys.github.io/smart-contract-best-practices/recommendations/#timestamp-dependence"},
	}

	// Weak randomness rule
	v.rules["weak_randomness"] = &VulnerabilityRule{
		ID:          "weak_randomness",
		Name:        "Weak Randomness Source",
		Description: "Contract uses weak randomness sources",
		Severity:    SeverityMedium,
		Category:    CategoryRandomness,
		Patterns:    []string{"40", "41", "42"}, // BLOCKHASH, COINBASE, TIMESTAMP opcodes
		Remediation: "Use secure randomness sources like Chainlink VRF",
		References:  []string{"https://consensys.github.io/smart-contract-best-practices/recommendations/#randomness"},
	}

	// Unprotected function rule
	v.rules["unprotected_function"] = &VulnerabilityRule{
		ID:          "unprotected_function",
		Name:        "Potentially Unprotected Function",
		Description: "Function may lack proper access control",
		Severity:    SeverityMedium,
		Category:    CategoryAccessControl,
		Patterns:    []string{"63"}, // CODECOPY opcode (often in function dispatching)
		Remediation: "Implement proper access control for sensitive functions",
		References:  []string{"https://consensys.github.io/smart-contract-best-practices/recommendations/#restrict-access-to-functions"},
	}

	// Gas limit DoS rule
	v.rules["gas_limit_dos"] = &VulnerabilityRule{
		ID:          "gas_limit_dos",
		Name:        "Gas Limit DoS",
		Description: "Contract may be vulnerable to gas limit DoS attacks",
		Severity:    SeverityMedium,
		Category:    CategoryDenialOfService,
		Patterns:    []string{"5b"}, // JUMPDEST opcode (loops)
		Remediation: "Avoid unbounded loops and implement gas-efficient patterns",
		References:  []string{"https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/"},
	}

	// Front-running rule
	v.rules["front_running"] = &VulnerabilityRule{
		ID:          "front_running",
		Name:        "Front-running Vulnerability",
		Description: "Contract may be vulnerable to front-running attacks",
		Severity:    SeverityLow,
		Category:    CategoryFrontRunning,
		Patterns:    []string{"32"}, // ORIGIN opcode
		Remediation: "Use commit-reveal schemes or other front-running protection",
		References:  []string{"https://consensys.github.io/smart-contract-best-practices/attacks/frontrunning/"},
	}
}
