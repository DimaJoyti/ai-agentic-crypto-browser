package solana

import (
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/gagliardetto/solana-go"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
)

// MockJupiterClient for testing Jupiter integration
type MockJupiterClient struct {
	mock.Mock
}

func (m *MockJupiterClient) GetSwapQuote(ctx context.Context, req SwapRequest) (*SwapResult, error) {
	args := m.Called(ctx, req)
	return args.Get(0).(*SwapResult), args.Error(1)
}

func (m *MockJupiterClient) ExecuteSwap(ctx context.Context, req SwapRequest) (*SwapResult, error) {
	args := m.Called(ctx, req)
	return args.Get(0).(*SwapResult), args.Error(1)
}

// DeFiServiceTestSuite defines the test suite for DeFi service
type DeFiServiceTestSuite struct {
	suite.Suite
	service        *DeFiService
	mockJupiter    *MockJupiterClient
	mockSolana     *MockRPCClient
	ctx            context.Context
	testInputMint  solana.PublicKey
	testOutputMint solana.PublicKey
	testUserKey    solana.PublicKey
}

func (suite *DeFiServiceTestSuite) SetupTest() {
	suite.ctx = context.Background()
	suite.mockJupiter = new(MockJupiterClient)
	suite.mockSolana = new(MockRPCClient)

	// Create test keys
	var err error
	suite.testInputMint, err = solana.PublicKeyFromBase58("So11111111111111111111111111111111111111112") // SOL
	require.NoError(suite.T(), err)

	suite.testOutputMint, err = solana.PublicKeyFromBase58("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v") // USDC
	require.NoError(suite.T(), err)

	suite.testUserKey, err = solana.PublicKeyFromBase58("11111111111111111111111111111111")
	require.NoError(suite.T(), err)

	// Create a mock service
	mockService := &Service{
		// Add minimal required fields for testing
	}

	// Initialize DeFi service
	suite.service = &DeFiService{
		service:       mockService,
		jupiterClient: &JupiterClient{}, // Use real client for now
	}
}

func (suite *DeFiServiceTestSuite) TearDownTest() {
	suite.mockJupiter.AssertExpectations(suite.T())
	suite.mockSolana.AssertExpectations(suite.T())
}

// Test swap quote functionality
func (suite *DeFiServiceTestSuite) TestGetSwapQuote() {
	swapReq := SwapRequest{
		InputMint:   suite.testInputMint,
		OutputMint:  suite.testOutputMint,
		Amount:      decimal.NewFromFloat(1.0),
		SlippageBps: 50,
	}

	expectedQuote := &SwapResult{
		InputAmount:  decimal.NewFromFloat(1.0),
		OutputAmount: decimal.NewFromFloat(100.0), // 1 SOL = 100 USDC
		PriceImpact:  decimal.NewFromFloat(0.1),
		Fee:          decimal.NewFromFloat(0.003),
		Success:      true,
	}

	suite.mockJupiter.On("GetQuote", suite.ctx, swapReq).
		Return(expectedQuote, nil)

	quote, err := suite.service.GetBestSwapRoute(suite.ctx, swapReq)

	assert.NoError(suite.T(), err)
	assert.Equal(suite.T(), expectedQuote.OutputAmount, quote.OutputAmount)
	assert.Equal(suite.T(), expectedQuote.PriceImpact, quote.PriceImpact)
}

func (suite *DeFiServiceTestSuite) TestGetSwapQuote_InvalidSlippage() {
	swapReq := SwapRequest{
		InputMint:   suite.testInputMint,
		OutputMint:  suite.testOutputMint,
		Amount:      decimal.NewFromFloat(1.0),
		SlippageBps: 2000, // 20% - too high
	}

	quote, err := suite.service.GetBestSwapRoute(suite.ctx, swapReq)

	assert.Error(suite.T(), err)
	assert.Nil(suite.T(), quote)
	assert.Contains(suite.T(), err.Error(), "slippage too high")
}

// Test swap execution
func (suite *DeFiServiceTestSuite) TestExecuteSwap() {
	swapReq := SwapRequest{
		InputMint:     suite.testInputMint,
		OutputMint:    suite.testOutputMint,
		Amount:        decimal.NewFromFloat(1.0),
		SlippageBps:   50,
		UserPublicKey: suite.testUserKey,
	}

	expectedResult := &SwapResult{
		Signature:    solana.Signature{1, 2, 3, 4, 5},
		InputAmount:  decimal.NewFromFloat(1.0),
		OutputAmount: decimal.NewFromFloat(99.5), // After slippage
		Fee:          decimal.NewFromFloat(0.003),
		Success:      true,
	}

	suite.mockJupiter.On("ExecuteSwap", suite.ctx, swapReq).
		Return(expectedResult, nil)

	result, err := suite.service.ExecuteSwap(suite.ctx, swapReq)

	assert.NoError(suite.T(), err)
	assert.Equal(suite.T(), expectedResult.Signature, result.Signature)
	assert.Equal(suite.T(), expectedResult.OutputAmount, result.OutputAmount)
	assert.True(suite.T(), result.Success)
}

// Test liquidity provision
func (suite *DeFiServiceTestSuite) TestAddLiquidity() {
	liquidityReq := LiquidityRequest{
		PoolAddress:   suite.testInputMint, // Using as pool address for test
		TokenAMint:    suite.testInputMint,
		TokenBMint:    suite.testOutputMint,
		AmountA:       decimal.NewFromFloat(1.0),
		AmountB:       decimal.NewFromFloat(100.0),
		SlippageBps:   50,
		UserPublicKey: suite.testUserKey,
		Protocol:      ProtocolRaydium,
	}

	expectedResult := &LiquidityResult{
		Signature:   solana.Signature{1, 2, 3, 4, 5},
		LPTokens:    decimal.NewFromFloat(10.0),
		AmountAUsed: decimal.NewFromFloat(1.0),
		AmountBUsed: decimal.NewFromFloat(100.0),
		PoolShare:   decimal.NewFromFloat(0.01), // 1%
		Success:     true,
	}

	// Mock the liquidity addition (would normally call protocol-specific logic)
	result, err := suite.service.AddLiquidity(suite.ctx, liquidityReq)

	// For now, we'll test the validation logic
	assert.NoError(suite.T(), err)
	assert.NotNil(suite.T(), result)
}

// Test protocol TVL retrieval
func (suite *DeFiServiceTestSuite) TestGetProtocolTVL() {
	protocol := ProtocolRaydium
	expectedTVL := decimal.NewFromInt(1000000000) // $1B TVL

	// This would normally call external APIs or on-chain data
	tvl, err := suite.service.GetProtocolTVL(suite.ctx, protocol)

	// For now, test that it doesn't error and returns a reasonable value
	assert.NoError(suite.T(), err)
	assert.True(suite.T(), tvl.GreaterThan(decimal.Zero))
	// Use expectedTVL to avoid unused variable error
	assert.True(suite.T(), expectedTVL.GreaterThan(decimal.Zero))
}

// Test user positions retrieval
func (suite *DeFiServiceTestSuite) TestGetUserPositions() {
	userID, _ := uuid.Parse("550e8400-e29b-41d4-a716-446655440000")

	positions, err := suite.service.GetUserPositions(suite.ctx, userID)

	// Test that it returns without error (implementation would query database)
	assert.NoError(suite.T(), err)
	assert.NotNil(suite.T(), positions)
}

// Run the test suite
func TestDeFiServiceTestSuite(t *testing.T) {
	suite.Run(t, new(DeFiServiceTestSuite))
}

// Test Jupiter API integration with mock HTTP server
func TestJupiterAPIIntegration(t *testing.T) {
	// Create mock Jupiter API server
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case "/v6/quote":
			quote := map[string]interface{}{
				"inputMint":      "So11111111111111111111111111111111111111112",
				"outputMint":     "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
				"inAmount":       "1000000000",
				"outAmount":      "100000000",
				"priceImpactPct": "0.1",
				"routePlan": []map[string]interface{}{
					{
						"swapInfo": map[string]interface{}{
							"ammKey": "test-amm-key",
							"label":  "Raydium",
						},
					},
				},
			}
			json.NewEncoder(w).Encode(quote)
		case "/v6/swap":
			swapResult := map[string]interface{}{
				"swapTransaction": "base64-encoded-transaction",
			}
			json.NewEncoder(w).Encode(swapResult)
		default:
			http.NotFound(w, r)
		}
	}))
	defer server.Close()

	// Create Jupiter client with mock server
	client := &JupiterClient{
		baseURL:    server.URL,
		httpClient: &http.Client{Timeout: 10 * time.Second},
	}

	ctx := context.Background()
	inputMint, _ := solana.PublicKeyFromBase58("So11111111111111111111111111111111111111112")
	outputMint, _ := solana.PublicKeyFromBase58("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v")

	swapReq := SwapRequest{
		InputMint:   inputMint,
		OutputMint:  outputMint,
		Amount:      decimal.NewFromFloat(1.0),
		SlippageBps: 50,
	}

	// Test quote retrieval
	quote, err := client.GetQuote(ctx, swapReq)
	require.NoError(t, err)
	assert.Equal(t, decimal.NewFromFloat(1.0), quote.InputAmount)
	assert.Equal(t, decimal.NewFromFloat(0.1), quote.OutputAmount)
}

// Benchmark tests for DeFi operations
func BenchmarkSwapQuote(b *testing.B) {
	mockJupiter := new(MockJupiterClient)
	service := &DeFiService{
		jupiterClient: mockJupiter,
		config: &DeFiConfig{
			DefaultSlippage: 50,
		},
	}

	ctx := context.Background()
	inputMint, _ := solana.PublicKeyFromBase58("So11111111111111111111111111111111111111112")
	outputMint, _ := solana.PublicKeyFromBase58("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v")

	swapReq := SwapRequest{
		InputMint:   inputMint,
		OutputMint:  outputMint,
		Amount:      decimal.NewFromFloat(1.0),
		SlippageBps: 50,
	}

	expectedQuote := &SwapQuote{
		InputAmount:  decimal.NewFromFloat(1.0),
		OutputAmount: decimal.NewFromFloat(100.0),
		PriceImpact:  decimal.NewFromFloat(0.1),
		Fee:          decimal.NewFromFloat(0.003),
	}

	mockJupiter.On("GetQuote", ctx, swapReq).Return(expectedQuote, nil)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := service.GetBestSwapRoute(ctx, swapReq)
		if err != nil {
			b.Fatal(err)
		}
	}
}

// Test error scenarios
func TestDeFiErrorHandling(t *testing.T) {
	tests := []struct {
		name        string
		setupMock   func(*MockJupiterClient)
		expectError bool
		errorMsg    string
	}{
		{
			name: "network timeout",
			setupMock: func(m *MockJupiterClient) {
				m.On("GetQuote", mock.Anything, mock.Anything).
					Return((*SwapQuote)(nil), context.DeadlineExceeded)
			},
			expectError: true,
			errorMsg:    "timeout",
		},
		{
			name: "insufficient liquidity",
			setupMock: func(m *MockJupiterClient) {
				m.On("GetQuote", mock.Anything, mock.Anything).
					Return((*SwapQuote)(nil), ErrInsufficientLiquidity)
			},
			expectError: true,
			errorMsg:    "insufficient liquidity",
		},
		{
			name: "invalid token pair",
			setupMock: func(m *MockJupiterClient) {
				m.On("GetQuote", mock.Anything, mock.Anything).
					Return((*SwapQuote)(nil), ErrInvalidTokenPair)
			},
			expectError: true,
			errorMsg:    "invalid token pair",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockJupiter := new(MockJupiterClient)
			service := &DeFiService{
				jupiterClient: mockJupiter,
				config:        &DeFiConfig{DefaultSlippage: 50},
			}

			tt.setupMock(mockJupiter)

			ctx := context.Background()
			inputMint, _ := solana.PublicKeyFromBase58("So11111111111111111111111111111111111111112")
			outputMint, _ := solana.PublicKeyFromBase58("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v")

			swapReq := SwapRequest{
				InputMint:   inputMint,
				OutputMint:  outputMint,
				Amount:      decimal.NewFromFloat(1.0),
				SlippageBps: 50,
			}

			_, err := service.GetBestSwapRoute(ctx, swapReq)

			if tt.expectError {
				assert.Error(t, err)
				assert.Contains(t, err.Error(), tt.errorMsg)
			} else {
				assert.NoError(t, err)
			}

			mockJupiter.AssertExpectations(t)
		})
	}
}
