package hft

import (
	"context"
	"fmt"
	"sync"
	"sync/atomic"
	"time"
	"unsafe"

	"github.com/ai-agentic-browser/pkg/observability"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

// FPGAAccelerator provides hardware-accelerated trading logic
// with nanosecond-precision tick-to-trade decisions
type FPGAAccelerator struct {
	logger *observability.Logger
	config FPGAConfig

	// Hardware interfaces (simulated)
	hardwareInterface *HardwareInterface

	// Lock-free queues for FPGA communication
	tickQueue     *LockFreeRingBuffer
	signalQueue   *LockFreeRingBuffer
	responseQueue *LockFreeRingBuffer

	// Performance metrics
	ticksProcessed      int64
	signalsGenerated    int64
	avgLatencyNanos     int64
	hardwareUtilization float64

	// State management
	isRunning int32
	stopChan  chan struct{}
	wg        sync.WaitGroup
	mu        sync.RWMutex

	// Strategy engines running on FPGA
	strategies map[string]*FPGAStrategy
}

// FPGAConfig contains configuration for FPGA acceleration
type FPGAConfig struct {
	// Hardware configuration
	DeviceID        string `json:"device_id"`        // FPGA device identifier
	ClockFrequency  int64  `json:"clock_frequency"`  // FPGA clock frequency in Hz
	MemorySize      int64  `json:"memory_size"`      // Available memory in bytes
	ProcessingUnits int    `json:"processing_units"` // Number of parallel processing units

	// Performance tuning
	TickBufferSize   int           `json:"tick_buffer_size"`   // Size of tick buffer
	SignalBufferSize int           `json:"signal_buffer_size"` // Size of signal buffer
	LatencyTarget    time.Duration `json:"latency_target"`     // Target latency for tick-to-trade

	// Strategy configuration
	MaxStrategies    int  `json:"max_strategies"`     // Maximum concurrent strategies
	RiskCheckEnabled bool `json:"risk_check_enabled"` // Enable hardware risk checks
	OrderValidation  bool `json:"order_validation"`   // Enable order validation

	// Monitoring
	EnableProfiling bool          `json:"enable_profiling"` // Enable performance profiling
	MetricsInterval time.Duration `json:"metrics_interval"` // Metrics collection interval
}

// HardwareInterface simulates the FPGA hardware interface
type HardwareInterface struct {
	deviceID       string
	isInitialized  bool
	clockFrequency int64
	memorySize     int64

	// Simulated hardware registers
	controlRegister uint64
	statusRegister  uint64
	dataRegister    uint64

	// Performance counters
	cycleCounter       uint64
	instructionCounter uint64

	mu sync.RWMutex
}

// FPGAStrategy represents a trading strategy running on FPGA
type FPGAStrategy struct {
	ID         string
	Name       string
	Type       StrategyType
	Parameters map[string]interface{}

	// Hardware allocation
	ProcessingUnit int
	MemoryOffset   int64
	MemorySize     int64

	// Performance metrics
	TicksProcessed   int64
	SignalsGenerated int64
	AvgLatencyNanos  int64

	// State
	IsActive   bool
	LastUpdate time.Time
}

// StrategyType represents different types of FPGA strategies
type StrategyType string

const (
	StrategyTypeMarketMaking  StrategyType = "MARKET_MAKING"
	StrategyTypeArbitrage     StrategyType = "ARBITRAGE"
	StrategyTypeMomentum      StrategyType = "MOMENTUM"
	StrategyTypeMeanReversion StrategyType = "MEAN_REVERSION"
	StrategyTypeStatArb       StrategyType = "STATISTICAL_ARBITRAGE"
)

// FPGATick represents a market tick optimized for FPGA processing
type FPGATick struct {
	// Packed data for efficient FPGA processing
	Symbol    uint32 // Symbol ID (mapped from string)
	Price     uint64 // Price in fixed-point format
	Size      uint64 // Size in fixed-point format
	Timestamp uint64 // Nanosecond timestamp
	Flags     uint32 // Side, type, and other flags

	// Derived data
	BidPrice uint64
	AskPrice uint64
	BidSize  uint64
	AskSize  uint64

	// Sequence and validation
	SequenceNumber uint64
	Checksum       uint32
}

// FPGASignal represents a trading signal generated by FPGA
type FPGASignal struct {
	// Signal identification
	ID         uint64
	StrategyID uint32
	Symbol     uint32

	// Order details
	Side      uint8  // 0=BUY, 1=SELL
	OrderType uint8  // 0=MARKET, 1=LIMIT, etc.
	Price     uint64 // Fixed-point price
	Quantity  uint64 // Fixed-point quantity

	// Timing and confidence
	Timestamp  uint64 // Nanosecond timestamp
	Confidence uint16 // Confidence level (0-65535)
	Priority   uint8  // Signal priority (0-255)

	// Risk and validation
	RiskScore uint16 // Risk score (0-65535)
	Validated uint8  // 0=not validated, 1=validated

	// Metadata
	Flags    uint32
	Reserved uint32
}

// NewFPGAAccelerator creates a new FPGA accelerator
func NewFPGAAccelerator(logger *observability.Logger, config FPGAConfig) *FPGAAccelerator {
	// Set default values
	if config.ClockFrequency == 0 {
		config.ClockFrequency = 300_000_000 // 300 MHz
	}
	if config.MemorySize == 0 {
		config.MemorySize = 8 * 1024 * 1024 * 1024 // 8 GB
	}
	if config.ProcessingUnits == 0 {
		config.ProcessingUnits = 16
	}
	if config.TickBufferSize == 0 {
		config.TickBufferSize = 1024 * 1024 // 1M ticks
	}
	if config.SignalBufferSize == 0 {
		config.SignalBufferSize = 100000 // 100K signals
	}
	if config.LatencyTarget == 0 {
		config.LatencyTarget = 100 * time.Nanosecond // 100ns target
	}

	accelerator := &FPGAAccelerator{
		logger:     logger,
		config:     config,
		strategies: make(map[string]*FPGAStrategy),
		stopChan:   make(chan struct{}),
	}

	// Initialize hardware interface
	accelerator.hardwareInterface = &HardwareInterface{
		deviceID:       config.DeviceID,
		clockFrequency: config.ClockFrequency,
		memorySize:     config.MemorySize,
	}

	// Initialize lock-free queues
	accelerator.tickQueue = NewLockFreeRingBuffer(config.TickBufferSize)
	accelerator.signalQueue = NewLockFreeRingBuffer(config.SignalBufferSize)
	accelerator.responseQueue = NewLockFreeRingBuffer(config.SignalBufferSize)

	return accelerator
}

// Start initializes and starts the FPGA accelerator
func (fa *FPGAAccelerator) Start(ctx context.Context) error {
	if !atomic.CompareAndSwapInt32(&fa.isRunning, 0, 1) {
		return fmt.Errorf("FPGA accelerator is already running")
	}

	fa.logger.Info(ctx, "Starting FPGA accelerator", map[string]interface{}{
		"device_id":        fa.config.DeviceID,
		"clock_frequency":  fa.config.ClockFrequency,
		"memory_size":      fa.config.MemorySize,
		"processing_units": fa.config.ProcessingUnits,
		"latency_target":   fa.config.LatencyTarget.Nanoseconds(),
	})

	// Initialize hardware
	if err := fa.initializeHardware(ctx); err != nil {
		return fmt.Errorf("failed to initialize FPGA hardware: %w", err)
	}

	// Load default strategies
	if err := fa.loadDefaultStrategies(ctx); err != nil {
		return fmt.Errorf("failed to load default strategies: %w", err)
	}

	// Start processing threads
	fa.wg.Add(fa.config.ProcessingUnits + 2)

	// Start tick processors
	for i := 0; i < fa.config.ProcessingUnits; i++ {
		go fa.processTicksOnFPGA(ctx, i)
	}

	// Start signal processor
	go fa.processSignals(ctx)

	// Start performance monitor
	go fa.performanceMonitor(ctx)

	fa.logger.Info(ctx, "FPGA accelerator started successfully", nil)
	return nil
}

// Stop gracefully shuts down the FPGA accelerator
func (fa *FPGAAccelerator) Stop(ctx context.Context) error {
	if !atomic.CompareAndSwapInt32(&fa.isRunning, 1, 0) {
		return fmt.Errorf("FPGA accelerator is not running")
	}

	fa.logger.Info(ctx, "Stopping FPGA accelerator", nil)

	close(fa.stopChan)
	fa.wg.Wait()

	// Shutdown hardware
	if err := fa.shutdownHardware(ctx); err != nil {
		fa.logger.Error(ctx, "Failed to shutdown FPGA hardware", err)
	}

	fa.logger.Info(ctx, "FPGA accelerator stopped", map[string]interface{}{
		"ticks_processed":   atomic.LoadInt64(&fa.ticksProcessed),
		"signals_generated": atomic.LoadInt64(&fa.signalsGenerated),
		"avg_latency_nanos": atomic.LoadInt64(&fa.avgLatencyNanos),
	})

	return nil
}

// ProcessTick processes a market tick on the FPGA
func (fa *FPGAAccelerator) ProcessTick(tick *NormalizedTick) error {
	if atomic.LoadInt32(&fa.isRunning) != 1 {
		return fmt.Errorf("FPGA accelerator is not running")
	}

	// Convert to FPGA-optimized format
	fpgaTick := fa.convertToFPGATick(tick)

	// Queue for FPGA processing
	tickPtr := unsafe.Pointer(fpgaTick)
	if !fa.tickQueue.Push(tickPtr) {
		return fmt.Errorf("FPGA tick queue is full")
	}

	return nil
}

// convertToFPGATick converts a normalized tick to FPGA format
func (fa *FPGAAccelerator) convertToFPGATick(tick *NormalizedTick) *FPGATick {
	// Convert string symbol to uint32 ID (simplified)
	symbolID := fa.getSymbolID(tick.Symbol)

	// Convert decimal prices to fixed-point format
	price := fa.decimalToFixedPoint(tick.Price)
	size := fa.decimalToFixedPoint(tick.Size)
	bidPrice := fa.decimalToFixedPoint(tick.BidPrice)
	askPrice := fa.decimalToFixedPoint(tick.AskPrice)
	bidSize := fa.decimalToFixedPoint(tick.BidSize)
	askSize := fa.decimalToFixedPoint(tick.AskSize)

	// Pack flags
	flags := uint32(0)
	if tick.Side == OrderSideBuy {
		flags |= 0x01
	}

	return &FPGATick{
		Symbol:         symbolID,
		Price:          price,
		Size:           size,
		Timestamp:      uint64(tick.ProcessTimestamp),
		Flags:          flags,
		BidPrice:       bidPrice,
		AskPrice:       askPrice,
		BidSize:        bidSize,
		AskSize:        askSize,
		SequenceNumber: tick.SequenceNumber,
		Checksum:       fa.calculateChecksum(symbolID, price, size),
	}
}

// getSymbolID converts a symbol string to a uint32 ID
func (fa *FPGAAccelerator) getSymbolID(symbol string) uint32 {
	// Simplified hash function - in production, use a proper symbol table
	hash := uint32(0)
	for _, c := range symbol {
		hash = hash*31 + uint32(c)
	}
	return hash
}

// decimalToFixedPoint converts a decimal to fixed-point format
func (fa *FPGAAccelerator) decimalToFixedPoint(d decimal.Decimal) uint64 {
	// Convert to fixed-point with 8 decimal places
	multiplier := decimal.NewFromInt(100000000) // 10^8
	fixed := d.Mul(multiplier)
	result, _ := fixed.Float64()
	return uint64(result)
}

// calculateChecksum calculates a simple checksum for data validation
func (fa *FPGAAccelerator) calculateChecksum(symbol uint32, price, size uint64) uint32 {
	return symbol ^ uint32(price) ^ uint32(size) ^ uint32(price>>32) ^ uint32(size>>32)
}

// initializeHardware initializes the FPGA hardware
func (fa *FPGAAccelerator) initializeHardware(ctx context.Context) error {
	fa.hardwareInterface.mu.Lock()
	defer fa.hardwareInterface.mu.Unlock()

	fa.logger.Info(ctx, "Initializing FPGA hardware", map[string]interface{}{
		"device_id": fa.hardwareInterface.deviceID,
	})

	// Simulate hardware initialization
	fa.hardwareInterface.controlRegister = 0x00000001 // Enable bit
	fa.hardwareInterface.statusRegister = 0x80000000  // Ready bit
	fa.hardwareInterface.isInitialized = true

	// Reset performance counters
	fa.hardwareInterface.cycleCounter = 0
	fa.hardwareInterface.instructionCounter = 0

	fa.logger.Info(ctx, "FPGA hardware initialized successfully", nil)
	return nil
}

// shutdownHardware shuts down the FPGA hardware
func (fa *FPGAAccelerator) shutdownHardware(ctx context.Context) error {
	fa.hardwareInterface.mu.Lock()
	defer fa.hardwareInterface.mu.Unlock()

	fa.logger.Info(ctx, "Shutting down FPGA hardware", nil)

	// Simulate hardware shutdown
	fa.hardwareInterface.controlRegister = 0x00000000 // Disable
	fa.hardwareInterface.statusRegister = 0x00000000  // Not ready
	fa.hardwareInterface.isInitialized = false

	return nil
}

// loadDefaultStrategies loads default trading strategies onto the FPGA
func (fa *FPGAAccelerator) loadDefaultStrategies(ctx context.Context) error {
	fa.logger.Info(ctx, "Loading default strategies onto FPGA", nil)

	// Market making strategy
	mmStrategy := &FPGAStrategy{
		ID:             "fpga_market_making_1",
		Name:           "High-Frequency Market Making",
		Type:           StrategyTypeMarketMaking,
		ProcessingUnit: 0,
		MemoryOffset:   0,
		MemorySize:     1024 * 1024, // 1MB
		IsActive:       true,
		Parameters: map[string]interface{}{
			"spread_bps":      5,    // 5 basis points
			"max_position":    1000, // Maximum position size
			"refresh_rate_ns": 1000, // Refresh every 1000ns
		},
	}

	// Arbitrage strategy
	arbStrategy := &FPGAStrategy{
		ID:             "fpga_arbitrage_1",
		Name:           "Cross-Exchange Arbitrage",
		Type:           StrategyTypeArbitrage,
		ProcessingUnit: 1,
		MemoryOffset:   1024 * 1024,
		MemorySize:     1024 * 1024, // 1MB
		IsActive:       true,
		Parameters: map[string]interface{}{
			"min_profit_bps": 2,    // Minimum 2 basis points profit
			"max_latency_ns": 5000, // Maximum 5000ns latency
		},
	}

	// Momentum strategy
	momentumStrategy := &FPGAStrategy{
		ID:             "fpga_momentum_1",
		Name:           "Ultra-Fast Momentum",
		Type:           StrategyTypeMomentum,
		ProcessingUnit: 2,
		MemoryOffset:   2 * 1024 * 1024,
		MemorySize:     1024 * 1024, // 1MB
		IsActive:       true,
		Parameters: map[string]interface{}{
			"lookback_ticks": 10,   // Look back 10 ticks
			"threshold_bps":  3,    // 3 basis points threshold
			"decay_factor":   0.95, // Exponential decay
		},
	}

	// Register strategies
	fa.strategies[mmStrategy.ID] = mmStrategy
	fa.strategies[arbStrategy.ID] = arbStrategy
	fa.strategies[momentumStrategy.ID] = momentumStrategy

	fa.logger.Info(ctx, "Default strategies loaded", map[string]interface{}{
		"strategies_count": len(fa.strategies),
	})

	return nil
}

// processTicksOnFPGA processes ticks on FPGA hardware
func (fa *FPGAAccelerator) processTicksOnFPGA(ctx context.Context, processingUnit int) {
	defer fa.wg.Done()

	fa.logger.Info(ctx, "Starting FPGA tick processor", map[string]interface{}{
		"processing_unit": processingUnit,
	})

	for {
		select {
		case <-fa.stopChan:
			return
		default:
			// Get tick from queue
			if tickPtr := fa.tickQueue.Pop(); tickPtr != nil {
				start := time.Now()
				tick := (*FPGATick)(tickPtr)

				// Process tick on FPGA
				signals := fa.executeStrategiesOnFPGA(tick, processingUnit)

				// Queue generated signals
				for _, signal := range signals {
					signalPtr := unsafe.Pointer(signal)
					if !fa.signalQueue.Push(signalPtr) {
						fa.logger.Warn(ctx, "Signal queue full, dropping signal", nil)
					}
				}

				// Update performance metrics
				latency := time.Since(start).Nanoseconds()
				atomic.StoreInt64(&fa.avgLatencyNanos, latency)
				atomic.AddInt64(&fa.ticksProcessed, 1)
				atomic.AddInt64(&fa.signalsGenerated, int64(len(signals)))
			} else {
				// No ticks available, yield CPU briefly
				time.Sleep(time.Nanosecond)
			}
		}
	}
}

// executeStrategiesOnFPGA executes trading strategies on FPGA
func (fa *FPGAAccelerator) executeStrategiesOnFPGA(tick *FPGATick, processingUnit int) []*FPGASignal {
	var signals []*FPGASignal

	// Find strategies assigned to this processing unit
	for _, strategy := range fa.strategies {
		if strategy.ProcessingUnit == processingUnit && strategy.IsActive {
			if signal := fa.executeStrategy(tick, strategy); signal != nil {
				signals = append(signals, signal)
			}
		}
	}

	return signals
}

// executeStrategy executes a single strategy on FPGA
func (fa *FPGAAccelerator) executeStrategy(tick *FPGATick, strategy *FPGAStrategy) *FPGASignal {
	// Simulate FPGA strategy execution
	switch strategy.Type {
	case StrategyTypeMarketMaking:
		return fa.executeMarketMakingStrategy(tick, strategy)
	case StrategyTypeArbitrage:
		return fa.executeArbitrageStrategy(tick, strategy)
	case StrategyTypeMomentum:
		return fa.executeMomentumStrategy(tick, strategy)
	default:
		return nil
	}
}

// executeMarketMakingStrategy executes market making strategy
func (fa *FPGAAccelerator) executeMarketMakingStrategy(tick *FPGATick, strategy *FPGAStrategy) *FPGASignal {
	// Simplified market making logic
	spreadBps := strategy.Parameters["spread_bps"].(int)
	spread := uint64(tick.Price * uint64(spreadBps) / 10000)

	// Generate buy signal below market
	if tick.Flags&0x01 == 0 { // If last tick was sell
		return &FPGASignal{
			ID:         atomic.AddUint64(&fa.hardwareInterface.instructionCounter, 1),
			StrategyID: fa.getStrategyID(strategy.ID),
			Symbol:     tick.Symbol,
			Side:       0, // BUY
			OrderType:  1, // LIMIT
			Price:      tick.Price - spread,
			Quantity:   tick.Size,
			Timestamp:  tick.Timestamp,
			Confidence: 8000, // 80% confidence
			Priority:   100,
			RiskScore:  1000, // Low risk
			Validated:  1,
		}
	}

	return nil
}

// executeArbitrageStrategy executes arbitrage strategy
func (fa *FPGAAccelerator) executeArbitrageStrategy(tick *FPGATick, strategy *FPGAStrategy) *FPGASignal {
	// Simplified arbitrage logic - would compare across exchanges
	minProfitBps := strategy.Parameters["min_profit_bps"].(int)
	minProfit := uint64(tick.Price * uint64(minProfitBps) / 10000)

	// Check if arbitrage opportunity exists (simplified)
	if tick.AskPrice > 0 && tick.BidPrice > 0 {
		spread := tick.AskPrice - tick.BidPrice
		if spread > minProfit*2 {
			return &FPGASignal{
				ID:         atomic.AddUint64(&fa.hardwareInterface.instructionCounter, 1),
				StrategyID: fa.getStrategyID(strategy.ID),
				Symbol:     tick.Symbol,
				Side:       0, // BUY
				OrderType:  0, // MARKET
				Price:      tick.BidPrice,
				Quantity:   tick.BidSize,
				Timestamp:  tick.Timestamp,
				Confidence: 9000, // 90% confidence
				Priority:   200,  // High priority
				RiskScore:  500,  // Very low risk
				Validated:  1,
			}
		}
	}

	return nil
}

// executeMomentumStrategy executes momentum strategy
func (fa *FPGAAccelerator) executeMomentumStrategy(tick *FPGATick, strategy *FPGAStrategy) *FPGASignal {
	// Simplified momentum logic
	thresholdBps := strategy.Parameters["threshold_bps"].(int)
	threshold := uint64(tick.Price * uint64(thresholdBps) / 10000)

	// Check for momentum (simplified - would use price history)
	if tick.Price > tick.BidPrice+threshold {
		return &FPGASignal{
			ID:         atomic.AddUint64(&fa.hardwareInterface.instructionCounter, 1),
			StrategyID: fa.getStrategyID(strategy.ID),
			Symbol:     tick.Symbol,
			Side:       0, // BUY
			OrderType:  0, // MARKET
			Price:      tick.Price,
			Quantity:   tick.Size / 2, // Half size
			Timestamp:  tick.Timestamp,
			Confidence: 7000, // 70% confidence
			Priority:   150,
			RiskScore:  2000, // Medium risk
			Validated:  1,
		}
	}

	return nil
}

// getStrategyID converts strategy ID string to uint32
func (fa *FPGAAccelerator) getStrategyID(strategyID string) uint32 {
	// Simple hash function
	hash := uint32(0)
	for _, c := range strategyID {
		hash = hash*31 + uint32(c)
	}
	return hash
}

// processSignals processes signals generated by FPGA strategies
func (fa *FPGAAccelerator) processSignals(ctx context.Context) {
	defer fa.wg.Done()

	fa.logger.Info(ctx, "Starting FPGA signal processor", nil)

	for {
		select {
		case <-fa.stopChan:
			return
		default:
			// Get signal from queue
			if signalPtr := fa.signalQueue.Pop(); signalPtr != nil {
				signal := (*FPGASignal)(signalPtr)

				// Convert FPGA signal to normalized format
				normalizedSignal := fa.convertFromFPGASignal(signal)

				// Queue for response processing
				responsePtr := unsafe.Pointer(normalizedSignal)
				if !fa.responseQueue.Push(responsePtr) {
					fa.logger.Warn(ctx, "Response queue full, dropping signal", nil)
				}
			} else {
				// No signals available, yield CPU briefly
				time.Sleep(time.Nanosecond)
			}
		}
	}
}

// convertFromFPGASignal converts FPGA signal to normalized format
func (fa *FPGAAccelerator) convertFromFPGASignal(fpgaSignal *FPGASignal) *TradingSignal {
	// Convert fixed-point back to decimal
	price := fa.fixedPointToDecimal(fpgaSignal.Price)
	quantity := fa.fixedPointToDecimal(fpgaSignal.Quantity)

	// Convert side
	var side OrderSide
	if fpgaSignal.Side == 0 {
		side = OrderSideBuy
	} else {
		side = OrderSideSell
	}

	// Convert order type
	var orderType OrderType
	switch fpgaSignal.OrderType {
	case 0:
		orderType = OrderTypeMarket
	case 1:
		orderType = OrderTypeLimit
	default:
		orderType = OrderTypeLimit
	}

	return &TradingSignal{
		ID:         uuid.New(),
		Symbol:     fa.getSymbolFromID(fpgaSignal.Symbol),
		Side:       side,
		OrderType:  orderType,
		Quantity:   quantity,
		Price:      price,
		Confidence: float64(fpgaSignal.Confidence) / 10000.0, // Convert from 0-65535 to 0-1
		StrategyID: fa.getStrategyFromID(fpgaSignal.StrategyID),
		Timestamp:  time.Unix(0, int64(fpgaSignal.Timestamp)),
		Metadata: map[string]interface{}{
			"fpga_generated": true,
			"priority":       fpgaSignal.Priority,
			"risk_score":     fpgaSignal.RiskScore,
			"validated":      fpgaSignal.Validated == 1,
		},
	}
}

// fixedPointToDecimal converts fixed-point format back to decimal
func (fa *FPGAAccelerator) fixedPointToDecimal(fixed uint64) decimal.Decimal {
	// Convert from fixed-point with 8 decimal places
	divisor := decimal.NewFromInt(100000000) // 10^8
	return decimal.NewFromInt(int64(fixed)).Div(divisor)
}

// getSymbolFromID converts symbol ID back to string
func (fa *FPGAAccelerator) getSymbolFromID(symbolID uint32) string {
	// In production, you'd maintain a symbol table
	// For now, return a default symbol
	return "BTCUSDT"
}

// getStrategyFromID converts strategy ID back to string
func (fa *FPGAAccelerator) getStrategyFromID(strategyID uint32) string {
	// Find strategy by ID hash
	for id, strategy := range fa.strategies {
		if fa.getStrategyID(id) == strategyID {
			return strategy.ID
		}
	}
	return "unknown_strategy"
}

// performanceMonitor tracks and reports FPGA performance metrics
func (fa *FPGAAccelerator) performanceMonitor(ctx context.Context) {
	ticker := time.NewTicker(fa.config.MetricsInterval)
	if fa.config.MetricsInterval == 0 {
		ticker = time.NewTicker(time.Second)
	}
	defer ticker.Stop()

	var lastTickCount int64
	var lastSignalCount int64

	for {
		select {
		case <-fa.stopChan:
			return
		case <-ticker.C:
			currentTicks := atomic.LoadInt64(&fa.ticksProcessed)
			currentSignals := atomic.LoadInt64(&fa.signalsGenerated)

			ticksPerSecond := currentTicks - lastTickCount
			signalsPerSecond := currentSignals - lastSignalCount

			lastTickCount = currentTicks
			lastSignalCount = currentSignals

			avgLatency := atomic.LoadInt64(&fa.avgLatencyNanos)

			// Calculate hardware utilization (simulated)
			fa.hardwareUtilization = float64(ticksPerSecond) / float64(fa.config.ClockFrequency) * 100.0
			if fa.hardwareUtilization > 100.0 {
				fa.hardwareUtilization = 100.0
			}

			fa.logger.Info(ctx, "FPGA accelerator performance", map[string]interface{}{
				"ticks_per_second":     ticksPerSecond,
				"signals_per_second":   signalsPerSecond,
				"avg_latency_nanos":    avgLatency,
				"hardware_utilization": fa.hardwareUtilization,
				"total_ticks":          currentTicks,
				"total_signals":        currentSignals,
				"active_strategies":    len(fa.strategies),
			})
		}
	}
}

// GetSignals returns a channel for receiving trading signals from FPGA
func (fa *FPGAAccelerator) GetSignals() <-chan *TradingSignal {
	signalChan := make(chan *TradingSignal, 1000)

	go func() {
		for {
			if responsePtr := fa.responseQueue.Pop(); responsePtr != nil {
				signal := (*TradingSignal)(responsePtr)
				select {
				case signalChan <- signal:
				default:
					// Channel full, drop signal
				}
			} else {
				time.Sleep(time.Microsecond)
			}
		}
	}()

	return signalChan
}

// GetMetrics returns current FPGA performance metrics
func (fa *FPGAAccelerator) GetMetrics() FPGAMetrics {
	return FPGAMetrics{
		TicksProcessed:      atomic.LoadInt64(&fa.ticksProcessed),
		SignalsGenerated:    atomic.LoadInt64(&fa.signalsGenerated),
		AvgLatencyNanos:     atomic.LoadInt64(&fa.avgLatencyNanos),
		HardwareUtilization: fa.hardwareUtilization,
		IsRunning:           atomic.LoadInt32(&fa.isRunning) == 1,
		ActiveStrategies:    len(fa.strategies),
		ClockFrequency:      fa.config.ClockFrequency,
		MemoryUsage:         fa.calculateMemoryUsage(),
	}
}

// FPGAMetrics contains performance metrics for the FPGA accelerator
type FPGAMetrics struct {
	TicksProcessed      int64   `json:"ticks_processed"`
	SignalsGenerated    int64   `json:"signals_generated"`
	AvgLatencyNanos     int64   `json:"avg_latency_nanos"`
	HardwareUtilization float64 `json:"hardware_utilization"`
	IsRunning           bool    `json:"is_running"`
	ActiveStrategies    int     `json:"active_strategies"`
	ClockFrequency      int64   `json:"clock_frequency"`
	MemoryUsage         float64 `json:"memory_usage"`
}

// calculateMemoryUsage calculates current memory usage percentage
func (fa *FPGAAccelerator) calculateMemoryUsage() float64 {
	var totalUsed int64
	for _, strategy := range fa.strategies {
		if strategy.IsActive {
			totalUsed += strategy.MemorySize
		}
	}
	return float64(totalUsed) / float64(fa.config.MemorySize) * 100.0
}

// AddStrategy adds a new strategy to the FPGA
func (fa *FPGAAccelerator) AddStrategy(strategy *FPGAStrategy) error {
	fa.mu.Lock()
	defer fa.mu.Unlock()

	// Check if processing unit is available
	for _, existingStrategy := range fa.strategies {
		if existingStrategy.ProcessingUnit == strategy.ProcessingUnit && existingStrategy.IsActive {
			return fmt.Errorf("processing unit %d is already in use", strategy.ProcessingUnit)
		}
	}

	// Check memory availability
	if strategy.MemoryOffset+strategy.MemorySize > fa.config.MemorySize {
		return fmt.Errorf("insufficient memory for strategy")
	}

	fa.strategies[strategy.ID] = strategy
	return nil
}

// RemoveStrategy removes a strategy from the FPGA
func (fa *FPGAAccelerator) RemoveStrategy(strategyID string) error {
	fa.mu.Lock()
	defer fa.mu.Unlock()

	if _, exists := fa.strategies[strategyID]; !exists {
		return fmt.Errorf("strategy %s not found", strategyID)
	}

	delete(fa.strategies, strategyID)
	return nil
}

// GetStrategies returns all active strategies
func (fa *FPGAAccelerator) GetStrategies() map[string]*FPGAStrategy {
	fa.mu.RLock()
	defer fa.mu.RUnlock()

	strategies := make(map[string]*FPGAStrategy)
	for id, strategy := range fa.strategies {
		strategies[id] = strategy
	}
	return strategies
}
